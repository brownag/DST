<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Keys to Soil Taxonomy</title>
    <script>
        // FOUC prevention: apply correct theme before first paint
        (function() {
            var ALL = ['dark', 'green', 'sepia', 'high-contrast'];
            var t = localStorage.getItem('dst-theme');
            ALL.forEach(function(c) { document.documentElement.classList.remove(c); });
            if (t === 'dark' || t === 'green' || t === 'sepia' || t === 'high-contrast') {
                document.documentElement.classList.add(t);
            } else if (!t || t === 'auto') {
                if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    document.documentElement.classList.add('dark');
                }
            }
        })();
    </script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container" x-data="app()" x-init="init()">
        <aside class="sidebar" :class="{ collapsed: sidebarCollapsed }">
            <div class="sidebar-title">Digital Keys to<br>Soil Taxonomy</div>
            <div class="sidebar-controls" style="display: flex; gap: 6px; align-items: center; justify-content: center; margin-bottom: 15px;">
                <button class="icon-btn" @click="currentTab = 'classify'" :title="currentTab === 'classify' ? 'Classify (active)' : 'Back to Classify'">âŒ‚</button>
                <button class="icon-btn" @click="reset()" title="Reset all selections">âŸ³</button>
                <button class="icon-btn" @click="showSatisfiedCriteria = !showSatisfiedCriteria" :title="showSatisfiedCriteria ? 'Hide satisfied criteria' : 'Show satisfied criteria'">
                    <span x-text="showSatisfiedCriteria ? 'âŠ™' : 'âŠ˜'"></span>
                </button>
                <button class="icon-btn" @click="cycleTheme()" :title="'Theme: ' + themeLabel">
                    <span x-text="themeIcon"></span>
                </button>
                <button class="icon-btn" @click="currentTab = 'about'" :title="currentTab === 'about' ? 'About (active)' : 'About this app'">â„¹</button>
                <button class="icon-btn" @click="sidebarCollapsed = !sidebarCollapsed" :title="sidebarCollapsed ? 'Expand sidebar' : 'Collapse sidebar'">
                    <span x-text="sidebarCollapsed ? 'â–¶' : 'â—€'"></span>
                </button>
            </div>

            <!-- Current classification result -->
            <template x-if="getClassificationPath().length > 0">
                <div class="current-classification">
                    <div class="result-label">Classification</div>
                    <div class="result-name" x-text="getCurrentClassification()"></div>
                    <div class="result-level" x-text="getClassificationLevel()"></div>
                </div>
            </template>

            <!-- Taxonomy hierarchy path -->
            <div class="classification-path">
                <div class="info-header">Taxonomy Path</div>
                <template x-if="getClassificationPath().length === 0">
                    <p class="hint-text">Select criteria to begin classification</p>
                </template>
                <template x-for="(step, idx) in getClassificationPath()" :key="step.levelName + idx">
                    <div class="classification-step" :class="step.satisfied ? 'satisfied' : 'pending'">
                        <div class="step-level" x-text="step.levelName"></div>
                        <span class="step-name" x-text="step.name"></span>
                        <span class="step-code" x-text="step.code"></span>
                    </div>
                </template>
            </div>

            <!-- Selected criteria detail -->
            <div class="selected-criteria-section">
                <div class="info-header">Selected Criteria</div>
                <template x-if="getCheckedCriteriaForSidebar().length === 0">
                    <p class="hint-text">No criteria checked yet</p>
                </template>
                <template x-for="criterion in getCheckedCriteriaForSidebar()" :key="getCriterionId(criterion)">
                    <div class="selected-criterion" @click="removeFromPath(getCriterionId(criterion))">
                        <strong x-text="criterion.clause_id"></strong>
                        <span class="remove-icon">Ã—</span>
                    </div>
                </template>
            </div>
        </aside>

        <div class="main">
            <header>
                <p x-show="currentTab === 'classify' && !findCurrentLevel()">Check criteria to classify your soil</p>
                <div class="breadcrumb" x-show="currentTab === 'classify' && findCurrentLevel()" x-text="getClassificationBreadcrumb()"></div>
            </header>

            <!-- About Tab -->
            <div class="about-panel" x-show="currentTab === 'about'">
                <div class="about-section">
                    <h2>About This Application</h2>
                    <p>Digital Keys to Soil Taxonomy is an interactive, offline-first Progressive Web App for USDA soil classification following the <a href="https://www.nrcs.usda.gov/resources/guides-and-instructions/keys-to-soil-taxonomy" target="_blank" rel="noopener">Keys to Soil Taxonomy (13th Edition, 2022)</a>.</p>
                    <p>The application guides you through the official USDA dichotomous key by progressively revealing classification criteria. Check the criteria that match your soil properties, and the app determines the taxonomic classification: Order â†’ Suborder â†’ Great Group â†’ Subgroup.</p>
                    <p>No internet connection is required after the first visit. The entire application â€” code, data, and glossary â€” is cached locally by the Service Worker.</p>
                </div>


                <div class="about-section">
                    <h2>Data Summary</h2>
                    <p x-show="engine">This dataset contains <strong x-text="engine ? engine.allCriteria.length : 'â€”'"></strong> decision criteria across <strong x-text="engine ? Object.keys(engine.outcomes).length : 'â€”'"></strong> soil taxonomy classifications. The glossary includes <strong x-text="engine ? Object.keys(engine.glossary).length : 'â€”'"></strong> soil science terms, mapped across <strong x-text="engine ? Object.keys(engine.codeNames).length : 'â€”'"></strong> taxonomic soil names (Orders, Suborders, Great Groups, and Subgroups).</p>
                </div>

                <div class="about-section">
                    <h2>JSON Data Schema <span class="version-badge">v1.0.0</span></h2>
                    <p>The application is powered by <code>data/dst-data.json</code>, a ~3.5 MB file generated from USDA source data. The file contains five top-level sections:</p>
                    <table class="about-table">
                        <thead><tr><th>Section</th><th>Description</th></tr></thead>
                        <tbody>
                            <tr><td><code>navigation.criteria</code></td><td>Array of decision criteria with clause hierarchy, AND/OR logic, and pre-linkified glossary terms</td></tr>
                            <tr><td><code>outcomes</code></td><td>Object keyed by taxonomic code â€” each is a classification result (depth -1)</td></tr>
                            <tr><td><code>glossary</code></td><td>Object keyed by term ID â€” soil science terms with definitions</td></tr>
                            <tr><td><code>order_names</code></td><td>Single-letter code â†’ Order name (e.g., A â†’ Gelisols)</td></tr>
                            <tr><td><code>code_names</code></td><td>Full code â†’ taxon name at all levels (e.g., AA â†’ Histels)</td></tr>
                        </tbody>
                    </table>
                    <h3>Criterion Fields</h3>
                    <table class="about-table">
                        <thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead>
                        <tbody>
                            <tr><td><code>crit</code></td><td>string</td><td>Hierarchical code (Aâ€“L Orders, AAâ€“LL Suborders, AAA+ deeper)</td></tr>
                            <tr><td><code>clause</code></td><td>number</td><td>Numeric clause ID within the group</td></tr>
                            <tr><td><code>parent_clause</code></td><td>number|""</td><td>Parent clause reference (empty for roots)</td></tr>
                            <tr><td><code>logic</code></td><td>string</td><td><code>OR</code> or <code>AND</code> â€” how this node's children relate</td></tr>
                            <tr><td><code>depth</code></td><td>number</td><td>0=Order, 1=Suborder, 2=Great Group, 3=Subgroup</td></tr>
                            <tr><td><code>content</code></td><td>string</td><td>Plain text criterion description</td></tr>
                            <tr><td><code>content_html</code></td><td>string</td><td>Content with glossary terms pre-linkified</td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="about-section">
                    <h2>DSTCore Engine</h2>
                    <p><code>scripts/dst-core.js</code> is a standalone, framework-agnostic logic engine with no DOM dependencies. It works identically in the browser (<code>window.DSTCore</code>) and Node.js (<code>require()</code>).</p>
                    <h3>Satisfaction Algorithm</h3>
                    <p>Each parent criterion's <code>logic</code> field determines how its children are evaluated:</p>
                    <ul>
                        <li><strong>AND</strong> â€” ALL children must be satisfied</li>
                        <li><strong>OR</strong> â€” at least ONE child must be satisfied</li>
                        <li><strong>Leaf nodes</strong> (no children) â€” satisfied when checked by the user</li>
                    </ul>
                    <p>Evaluation is recursive with per-mutation cache invalidation.</p>
                    <h3>Key API Methods</h3>
                    <table class="about-table">
                        <thead><tr><th>Method</th><th>Returns</th><th>Description</th></tr></thead>
                        <tbody>
                            <tr><td><code>DSTCore.create(data)</code></td><td>engine</td><td>Create engine instance from parsed JSON</td></tr>
                            <tr><td><code>engine.check(id)</code></td><td>â€”</td><td>Check a criterion (auto-invalidates caches)</td></tr>
                            <tr><td><code>engine.toggle(id)</code></td><td>â€”</td><td>Toggle check state</td></tr>
                            <tr><td><code>engine.reset()</code></td><td>â€”</td><td>Clear all checks</td></tr>
                            <tr><td><code>engine.isClauseSatisfied(c)</code></td><td>boolean</td><td>Recursive satisfaction check (cached)</td></tr>
                            <tr><td><code>engine.isGroupSatisfied(code)</code></td><td>boolean</td><td>Is an entire taxonomic group satisfied?</td></tr>
                            <tr><td><code>engine.getVisibleGroups()</code></td><td>array</td><td>Groups to display at current level</td></tr>
                            <tr><td><code>engine.getClassificationPath()</code></td><td>array</td><td>Current taxonomy path (Order â†’ Subgroup)</td></tr>
                            <tr><td><code>engine.getCurrentClassification()</code></td><td>string</td><td>Name of deepest satisfied taxon</td></tr>
                            <tr><td><code>engine.onChange(fn)</code></td><td>unsubscribe</td><td>Register state change listener</td></tr>
                        </tbody>
                    </table>
                </div>

                <div class="about-section">
                    <h2>Technology Stack</h2>
                    <p><strong>Frontend:</strong> Alpine.js v3.13.3 (loaded via CDN), CSS with custom properties for light/dark theming</p>
                    <p><strong>Engine:</strong> Standalone JavaScript logic engine (<code>scripts/dst-core.js</code>) with no dependencies. Works identically in browser and Node.js.</p>
                    <p><strong>Data:</strong> Python preprocessing pipeline generates optimized JSON from USDA source files. Service Worker enables offline-first caching.</p>
                    <p><strong>Testing:</strong> Custom test harness with Node.js and browser execution modes.</p>
                </div>

                <div class="about-section">
                    <h2>Resources</h2>
                    <ul>
                        <li><a href="https://github.com/ncss-tech/SoilKnowledgeBase" target="_blank" rel="noopener">Soil Knowledge Base</a> â€” Official NCSS taxonomy data repository</li>
                        <li><a href="https://www.nrcs.usda.gov/resources/guides-and-instructions/keys-to-soil-taxonomy" target="_blank" rel="noopener">USDA Keys to Soil Taxonomy</a> â€” Official classification guide</li>
                    </ul>
                </div>

                <div class="about-section">
                    <h2>Source &amp; License</h2>
                    <ul>
                        <li><strong>Code</strong>: MIT License</li>
                        <li><strong>Taxonomy Data</strong>: Derived from USDA <em>Keys to Soil Taxonomy</em> â€” public domain</li>
                        <li><strong>USDA Source</strong>: <a href="https://www.nrcs.usda.gov/resources/guides-and-instructions/keys-to-soil-taxonomy" target="_blank" rel="noopener">nrcs.usda.gov</a></li>
                        <li><strong>Source Data</strong>: <a href="https://github.com/ncss-tech/SoilKnowledgeBase" target="_blank" rel="noopener">SoilKnowledgeBase (GitHub)</a></li>
                    </ul>
                </div>

                <div class="about-section about-footer">
                    <div style="text-align: center; font-size: 13px; color: var(--color-text-muted);">
                        <p><strong>Digital Keys to Soil Taxonomy</strong><br>
                        Version <span x-text="appVersion || '1.0.0'"></span></p>
                        <p>Created by Andrew G. Brown</p>
                    </div>
                </div>
            </div>

            <!-- Classify Tab -->
            <div class="content-with-panel" x-show="currentTab === 'classify'">
                <div class="content" x-show="!loading" @click="handleTermClick($event)" @mouseover="handleTermHover($event)">
                    <template x-if="error">
                        <div class="error" x-text="error"></div>
                    </template>

                    <template x-for="group in visibleGroups" :key="group.code">
                        <div class="criteria-group" x-show="showSatisfiedCriteria || !isGroupSatisfied(group.code)" :class="{ complete: isGroupSatisfied(group.code) }">
                            <h3>
                                <span x-text="group.code"></span>: <span x-text="group.label"></span>
                                <template x-if="isGroupSatisfied(group.code)">
                                    <span class="satisfied-badge"> &#10003; satisfied</span>
                                </template>
                            </h3>
                            <template x-for="criterion in group.items" :key="getCriterionId(criterion)">
                                <div class="criterion"
                                     x-show="showSatisfiedCriteria || !isClauseSatisfied(criterion) || !isLeafCriterion(criterion)"
                                     :class="{
                                         'criterion-header': !isLeafCriterion(criterion) && criterion.depth === 0,
                                         'criterion-parent': !isLeafCriterion(criterion) && criterion.depth > 0,
                                         'criterion-satisfied': isClauseSatisfied(criterion)
                                     }"
                                     :style="{ marginLeft: criterion.depth * 20 + 'px' }">
                                    <!-- Leaf criterion: user-checkable -->
                                    <template x-if="isLeafCriterion(criterion)">
                                        <input type="checkbox" :id="getCriterionId(criterion)" @change="checkCriterion(getCriterionId(criterion))" :checked="checkedCriteria[getCriterionId(criterion)]">
                                    </template>
                                    <!-- Structural header (depth 0): auto-computed status -->
                                    <template x-if="!isLeafCriterion(criterion) && criterion.depth === 0">
                                        <span class="auto-status" :class="isClauseSatisfied(criterion) ? 'status-satisfied' : 'status-unsatisfied'" x-text="isClauseSatisfied(criterion) ? 'âœ“' : 'â—‹'"></span>
                                    </template>
                                    <!-- Inline parent (depth > 0): checkbox-like status -->
                                    <template x-if="!isLeafCriterion(criterion) && criterion.depth > 0">
                                        <span class="inline-status" :class="isClauseSatisfied(criterion) ? 'status-satisfied' : 'status-unsatisfied'" x-text="isClauseSatisfied(criterion) ? 'âœ“' : 'â—‹'"></span>
                                    </template>
                                    <label :for="isLeafCriterion(criterion) ? getCriterionId(criterion) : null">
                                        <span x-html="criterion.content_html || criterion.content"></span>
                                        <span class="logic-badge" :class="criterion.logic === 'OR' ? 'logic-or' : 'logic-and'" x-text="criterion.logic || 'AND'" x-show="isLeafCriterion(criterion) && (engine.clauseChildrenMap[engine.getCriterionId({crit: criterion.crit, clause: criterion.parent_clause})] || []).length > 1"></span>
                                    </label>
                                </div>
                            </template>
                        </div>
                    </template>
                </div>

                <div class="loading" x-show="loading"><p>Loading criteria...</p></div>

                <div class="info-panel" :class="{ hidden: !infoPanelOpen }">
                    <div class="info-panel-controls">
                        <input type="text" x-model="definitionSearch" class="search-input" placeholder="Filter definitions...">
                        <button class="icon-btn" @click="infoPanelOpen = false" title="Close panel">âœ•</button>
                        <button class="icon-btn" @click="viewedHistory = []; definitionSearch = ''" title="Clear all history">âŠŸ</button>
                    </div>
                    <template x-if="currentTerm && infoPanelOpen">
                        <div style="padding: 20px; overflow-y: auto; flex: 1;">
                            <div class="info-header">Term Definition</div>
                            <div class="current-term">
                                <h3 x-text="currentTerm.term"></h3>
                                <p x-text="currentTerm.definition"></p>
                            </div>
                            <div class="info-header">Recently Viewed</div>
                            <div class="viewed-history">
                                <template x-for="item in getFilteredHistory()" :key="item.id">
                                    <div class="history-item" @click="selectViewed(item)"><strong x-text="item.term"></strong></div>
                                </template>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>
    </div>

    <script src="scripts/dst-core.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.3/dist/cdn.min.js" defer></script>
    <script>
        /*
         * ============================================
         * DIGITAL KEYS TO SOIL TAXONOMY â€” ALPINE.JS UI
         * ============================================
         * Thin Alpine shell delegating all pure logic to DSTCore engine.
         * See scripts/dst-core.js for the standalone library.
         */
        function app() {
            return {
                // --- State ---
                appVersion: '1.0.0',
                engine: null,
                loading: true,
                error: null,
                checkedCriteria: {},
                visibleGroups: [],
                currentTerm: null,
                viewedHistory: [],
                currentTab: 'classify',
                theme: localStorage.getItem('dst-theme') || 'auto',
                showSatisfiedCriteria: true,
                sidebarCollapsed: false,
                infoPanelOpen: false,
                definitionSearch: '',

                // --- Theme ---

                get themeIcon() {
                    return {
                        auto: 'â—', light: 'â˜€', dark: 'â˜¾',
                        green: 'â˜˜', sepia: 'ðŸ“„ï¸Ž', 'high-contrast': 'â—ˆ'
                    }[this.theme] || 'â—';
                },
                get themeLabel() {
                    return {
                        auto: 'Auto', light: 'Light', dark: 'Dark',
                        green: 'Green', sepia: 'Sepia', 'high-contrast': 'High Contrast'
                    }[this.theme] || 'Auto';
                },
                cycleTheme() {
                    var order = ['auto', 'light', 'dark', 'green', 'sepia', 'high-contrast'];
                    var idx = order.indexOf(this.theme);
                    if (idx === -1) idx = 0;
                    this.theme = order[(idx + 1) % order.length];
                    if (this.theme === 'auto') localStorage.removeItem('dst-theme');
                    else localStorage.setItem('dst-theme', this.theme);
                    this.applyTheme();
                },
                applyTheme() {
                    var el = document.documentElement;
                    ['dark', 'green', 'sepia', 'high-contrast'].forEach(function(c) { el.classList.remove(c); });
                    if (this.theme === 'dark') {
                        el.classList.add('dark');
                    } else if (this.theme === 'auto') {
                        if (window.matchMedia('(prefers-color-scheme: dark)').matches) el.classList.add('dark');
                    } else if (this.theme === 'green' || this.theme === 'sepia' || this.theme === 'high-contrast') {
                        el.classList.add(this.theme);
                    }
                },

                // --- Engine Delegation ---

                getCriterionId(c) { return this.engine.getCriterionId(c); },
                isLeafCriterion(c) { return this.engine.isLeafCriterion(c); },
                isClauseSatisfied(c) { return this.engine.isClauseSatisfied(c); },
                isGroupSatisfied(code) { return this.engine.isGroupSatisfied(code); },
                findCurrentLevel() { return this.engine ? this.engine.findCurrentLevel() : null; },
                getClassificationPath() { return this.engine ? this.engine.getClassificationPath() : []; },
                getCurrentClassification() { return this.engine ? this.engine.getCurrentClassification() : ''; },
                getClassificationLevel() { return this.engine ? this.engine.getClassificationLevel() : ''; },
                getClassificationBreadcrumb() { return this.engine ? this.engine.getClassificationBreadcrumb() : ''; },
                removeCodePrefix(content, code) { return this.engine.removeCodePrefix(content, code); },
                getCheckedCriteriaForSidebar() { return this.engine ? this.engine.getCheckedLeaves() : []; },

                // --- Data Initialization ---

                async init() {
                    try {
                        this.applyTheme();
                        var self = this;
                        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function() {
                            if (self.theme === 'auto') self.applyTheme();
                        });

                        var response = await fetch('data/dst-data.json');
                        if (!response.ok) throw new Error('HTTP ' + response.status);
                        var data = await response.json();

                        this.engine = DSTCore.create(data);
                        this.visibleGroups = this.engine.getVisibleGroups();
                        this.loading = false;
                    } catch (err) {
                        this.error = 'Failed to load: ' + err.message;
                        this.loading = false;
                    }
                },

                // --- User Interactions ---

                checkCriterion(id) {
                    this.engine.toggle(id);
                    this._syncState();
                },
                removeFromPath(id) {
                    this.engine.uncheck(id);
                    this._syncState();
                },
                reset() {
                    this.engine.reset();
                    this.currentTerm = null;
                    this.viewedHistory = [];
                    this._syncState();
                },
                _syncState() {
                    this.checkedCriteria = Object.assign({}, this.engine.checkedCriteria);
                    this.visibleGroups = this.engine.getVisibleGroups();
                },

                getFilteredHistory() {
                    if (!this.definitionSearch) return this.viewedHistory;
                    var search = this.definitionSearch.toLowerCase();
                    return this.viewedHistory.filter(function(item) {
                        return item.term.toLowerCase().includes(search);
                    });
                },

                // --- Glossary ---

                handleTermClick(event) {
                    var span = event.target.closest('.glossary-term');
                    if (span) {
                        event.preventDefault();
                        event.stopPropagation();
                        var termId = span.getAttribute('data-id');
                        this.selectTerm(termId);
                    }
                },
                handleTermHover(event) {
                    var span = event.target.closest('.glossary-term');
                    if (span) {
                        var termId = span.getAttribute('data-id');
                        var term = this.engine.glossary[termId];
                        if (term && !span.title) {
                            span.title = term.term + '\n\n' + term.definition;
                        }
                    }
                },
                selectTerm(termId) {
                    var term = this.engine.glossary[termId];
                    if (term) {
                        this.currentTerm = term;
                        this.infoPanelOpen = true;
                        if (!this.viewedHistory.find(function(h) { return h.id === termId; })) {
                            this.viewedHistory.unshift(term);
                            if (this.viewedHistory.length > 10) this.viewedHistory.pop();
                        }
                    }
                },
                selectViewed(item) {
                    this.currentTerm = item;
                    this.infoPanelOpen = true;
                }
            };
        }
    </script>
</body>
</html>